#!/bin/bash

# Ansible managed: Do NOT edit this file manually!

########################################################################
# Matthew's Git Bash Prompt
########################################################################

source $HOME/.bash_colors

df=$(if [[ -x "/usr/xpg4/bin/df" ]]; then echo /usr/xpg4/bin/df ; else echo df; fi)

function parse_git_branch {
  git rev-parse --git-dir > /dev/null 2>&1
  if [[ $? -eq 0 ]]; then
    git_branch="$(git symbolic-ref HEAD 2> /dev/null | awk -F/ '{print $3;}')"
    localDisk="$($df -Ph . | grep '^/')"
    if [[ -z "$localDisk" ]]; then
      localDisk="$($df -Ph . | grep '^home')"
    fi
    if [[ -z "$localDisk" ]]; then
      git_status="working directory clean"
    else
      git_status="$(git status 2> /dev/null)"
    fi
    branch_pattern="^# On branch ([^${IFS}]*)"
    detached_branch_pattern="# Not currently on any branch"
    remote_pattern_ahead="# Your branch is ahead of"
    remote_pattern_behind="# Your branch is behind"
    diverge_pattern="# Your branch and (.*) have diverged"
    untracked_pattern="# Untracked files:"
    new_pattern="new file:"
    not_staged_pattern="Changes not staged for commit"
    status_pattern="working (directory|tree) clean"
    color="${Green}"

    # didn't run status on nfs disk state unknown
    if [[ -z "$localDisk" ]]; then
      state="?"
    fi
    #files not staged for commit
    if [[ ! ${git_status} =~ ${status_pattern} ]]; then
      color="${Red}"
      state="⚡"
    fi
    # add an else if or two here if you want to get more specific
    # show if we're ahead or behind HEAD
    if [[ ${git_status} =~ ${remote_pattern_ahead} ]]; then
      remote="${Yellow}↑"
    fi
    if [[ ${git_status} =~ ${remote_pattern_behind} ]]; then
      remote="${Yellow}↓"
    fi
    #new files
    if [[ ${git_status} =~ ${new_pattern} ]]; then
      remote="${Yellow}+"
    fi
    #untracked files
    if [[ ${git_status} =~ ${untracked_pattern} ]]; then
      remote="${Yellow}✖"
    fi
    #diverged branch
    if [[ ${git_status} =~ ${diverge_pattern} ]]; then
      remote="${Yellow}↕"
    fi
    #branch name
    if [[ ${git_status} =~ ${branch_pattern} ]]; then
      branch=${BASH_REMATCH[1]}
    #detached branch
    elif [[ ${git_status} =~ ${detached_branch_pattern} ]]; then
      branch="NO BRANCH"
    else
      branch="${git_branch}"
    fi

    echo " ${color}(${branch}${state}${remote}${color})"
  fi
  return
}

function git_dirty_flag {
  git status 2> /dev/null | grep -c : | awk '{if ($1 > 0) print "⚡"}'
}

function prompt_func() {
    previous_return_value=$?;
    #The lowercase w is the full current working directory
    #prompt="${TITLEBAR}${Blue}[${Red}\w${Green}$(parse_git_branch)${Blue}]${Color_Off}"
    
    #Capital W is just the trailing part of the current working directory
    prompt="${TITLEBAR}${Cyan}\u@\h${Blue}[${Purple}\W$(parse_git_branch)${Blue}]${Color_Off}"
    
    if test $previous_return_value -eq 0
    then
        PS1="${prompt}> "
    else
        PS1="${prompt}${Red}>${Color_Off} "
    fi
}

PROMPT_COMMAND=prompt_func
